<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>智能制造视觉检测系统 (V14)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady();" onerror="onOpenCvError();" type="text/javascript"></script>
    <script>
        tailwind.config = { theme: { extend: { colors: { primary: '#165DFF', success: '#00B42A', danger: '#F53F3F' } } } }
    </script>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col">
    <div id="error-msg" class="hidden fixed top-20 left-1/2 transform -translate-x-1/2 bg-red-600 text-white px-6 py-3 rounded shadow-lg z-50"></div>

    <header class="bg-primary text-white shadow-md">
        <div class="container mx-auto px-4 py-3 flex justify-between items-center">
            <h1 class="text-xl font-bold">视觉系统 <span class="bg-white text-primary text-xs px-2 py-1 rounded ml-2">V14(数据修复版)</span></h1>
            <span id="status" class="bg-yellow-500 text-xs px-2 py-1 rounded">正在下载库...</span>
        </div>
    </header>

    <main class="flex-1 container mx-auto px-4 py-6">
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <div class="space-y-4">
                <div class="bg-black rounded-lg overflow-hidden relative aspect-[4/3] shadow-lg">
                    <video id="video" width="640" height="480" class="absolute inset-0 w-full h-full object-contain" muted playsinline></video>
                    <canvas id="canvas" width="640" height="480" class="absolute inset-0 w-full h-full object-contain"></canvas>
                </div>
                
                <div class="flex gap-2">
                    <button onclick="document.getElementById('ref-input').click()" class="flex-1 bg-blue-600 text-white py-3 rounded font-bold">1. 上传模板</button>
                    <input type="file" id="ref-input" accept="image/*" class="hidden">
                    
                    <button id="btn-cam" onclick="toggleCamera()" class="flex-1 bg-gray-400 text-white py-3 rounded font-bold" disabled>2. 启动摄像头</button>
                    
                    <button id="btn-img" onclick="document.getElementById('test-input').click()" class="flex-1 bg-gray-400 text-white py-3 rounded font-bold" disabled>或 图片测试</button>
                    <input type="file" id="test-input" accept="image/*" class="hidden">
                </div>
            </div>

            <div class="bg-white p-6 rounded-lg shadow-lg h-fit">
                <h2 class="text-lg font-bold border-b pb-2 mb-4">实时数据</h2>
                <div class="grid grid-cols-2 gap-4 text-center mb-6">
                    <div class="p-4 bg-gray-50 rounded">
                        <div class="text-gray-500 text-sm">识别颜色</div>
                        <div id="out-color" class="text-2xl font-bold text-gray-300">--</div>
                    </div>
                    <div class="p-4 bg-gray-50 rounded">
                        <div class="text-gray-500 text-sm">旋转角度</div>
                        <div id="out-angle" class="text-2xl font-bold text-gray-300">--°</div>
                    </div>
                </div>
                <div class="text-xs font-mono bg-gray-900 text-green-400 p-4 rounded h-64 overflow-y-auto" id="logs"></div>
            </div>
        </div>
    </main>

    <script>
        let stream = null, isRunning = false;
        let video = document.getElementById('video');
        let canvas = document.getElementById('canvas');
        let ctx = canvas.getContext('2d');
        
        // === 内存池 (Memory Pool) ===
        // 核心修正：只创建一次，永不销毁，只覆盖数据
        let matSrc = null, matDst = null, matGray = null, matHsv = null;
        let matMask = null, matRoi = null, matBlur = null;
        let matLowR1=null, matHighR1=null, matLowR2=null, matHighR2=null, matLowB=null, matHighB=null;
        
        // ORB 相关
        let orb = null, matcher = null;
        let refKp = null, refDesc = null;
        let webKp = null, webDesc = null;
        let matches = null;
        let goodMatches = []; // JS数组
        let refImgReady = false;
        
        // 矩阵缓存 (用于 Homography)
        let matHomSrc = null, matHomDst = null, matHomMask = null, matH = null;

        function log(msg) {
            let box = document.getElementById('logs');
            box.innerHTML = `<div>[${new Date().toLocaleTimeString().split(' ')[0]}] ${msg}</div>` + box.innerHTML;
        }

        function showError(msg) {
            let el = document.getElementById('error-msg');
            el.textContent = msg;
            el.classList.remove('hidden');
            setTimeout(() => el.classList.add('hidden'), 3000);
        }

        // === 1. 初始化 OpenCV ===
        function onOpenCvReady() {
            document.getElementById('status').textContent = "OpenCV 就绪";
            document.getElementById('status').className = "bg-green-600 text-white text-xs px-2 py-1 rounded";
            log("库加载成功。正在分配内存池...");
            
            try {
                // 预分配所有需要的矩阵 (640x480)
                matSrc = new cv.Mat(480, 640, cv.CV_8UC4);
                matDst = new cv.Mat(480, 640, cv.CV_8UC3);
                matGray = new cv.Mat();
                matHsv = new cv.Mat();
                matMask = new cv.Mat(480, 640, cv.CV_8UC1);
                matRoi = new cv.Mat();
                matBlur = new cv.Mat();
                
                // 阈值矩阵
                matLowR1 = new cv.Mat(480, 640, cv.CV_8UC3, [0, 50, 50, 0]);
                matHighR1 = new cv.Mat(480, 640, cv.CV_8UC3, [10, 255, 255, 0]);
                matLowR2 = new cv.Mat(480, 640, cv.CV_8UC3, [170, 50, 50, 0]);
                matHighR2 = new cv.Mat(480, 640, cv.CV_8UC3, [180, 255, 255, 0]);
                matLowB = new cv.Mat(480, 640, cv.CV_8UC3, [100, 50, 50, 0]);
                matHighB = new cv.Mat(480, 640, cv.CV_8UC3, [125, 255, 255, 0]);
                
                // 算法对象
                orb = new cv.ORB(1500);
                matcher = new cv.BFMatcher(cv.NORM_HAMMING, false);
                refKp = new cv.KeyPointVector();
                refDesc = new cv.Mat();
                webKp = new cv.KeyPointVector();
                webDesc = new cv.Mat();
                matches = new cv.DMatchVectorVector();
                
                // Homography 专用缓存
                matHomMask = new cv.Mat();
                matH = new cv.Mat();

                log("内存池分配完毕。请上传 1.jpg");
            } catch(e) {
                showError("内存分配失败，请刷新");
                log(e);
            }
        }

        function onOpenCvError() {
            showError("OpenCV库下载失败！请检查网络。");
        }

        // === 2. 上传模板 ===
        document.getElementById('ref-input').onchange = function(e) {
            if(!matSrc) return;
            let file = e.target.files[0];
            if(!file) return;
            
            let img = new Image();
            img.onload = function() {
                try {
                    let temp = cv.imread(img);
                    let tempGray = new cv.Mat();
                    cv.cvtColor(temp, tempGray, cv.COLOR_RGBA2GRAY);
                    
                    // 提取特征
                    orb.detectAndCompute(tempGray, new cv.Mat(), refKp, refDesc);
                    
                    refImgReady = true;
                    log(`模板载入成功！特征点: ${refKp.size()}`);
                    
                    // 解锁按钮
                    document.getElementById('btn-cam').disabled = false;
                    document.getElementById('btn-cam').className = "flex-1 bg-blue-600 text-white py-3 rounded font-bold";
                    document.getElementById('btn-img').disabled = false;
                    document.getElementById('btn-img').className = "flex-1 bg-yellow-500 text-white py-3 rounded font-bold";
                    
                    temp.delete(); tempGray.delete();
                } catch(e) { log("模板错误: " + e); }
            };
            img.src = URL.createObjectURL(file);
        }

        // === 3. 核心循环 ===
        function startLoop() {
            if(!isRunning) return;
            try {
                let cap = new cv.VideoCapture(video);
                // 核心修复：防止 VideoCapture 报错
                if(video.readyState === 4) {
                    cap.read(matSrc); // 读取到 matSrc
                    processFrame();   // 处理
                }
            } catch(e) {
                // 忽略读取错误，继续下一帧
            }
            requestAnimationFrame(startLoop);
        }

        // === 4. 图片测试 ===
        document.getElementById('test-input').onchange = function(e) {
            let file = e.target.files[0];
            if(!file) return;
            
            // 停止摄像头
            if(stream) {
                stream.getTracks().forEach(t => t.stop());
                isRunning = false;
            }
            
            let img = new Image();
            img.onload = function() {
                // 强制画到 canvas 并读取
                ctx.drawImage(img, 0, 0, 640, 480);
                // 给一点时间让 canvas 渲染
                setTimeout(() => {
                    matSrc = cv.imread(canvas);
                    processFrame();
                    log("图片识别完成");
                }, 100);
            };
            img.src = URL.createObjectURL(file);
        }

        // === 5. 摄像头开关 ===
        async function toggleCamera() {
            if(isRunning) {
                isRunning = false;
                if(stream) stream.getTracks().forEach(t => t.stop());
                document.getElementById('btn-cam').innerText = "2. 启动摄像头";
                return;
            }
            
            try {
                stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { width: {ideal: 640}, height: {ideal: 480}, facingMode: 'environment' }, 
                    audio: false 
                });
                video.srcObject = stream;
                video.play();
                isRunning = true;
                document.getElementById('btn-cam').innerText = "停止";
                startLoop();
            } catch(e) { showError(e.message); }
        }

        // === 6. 核心算法 (无内存分配版) ===
        function processFrame() {
            // A. 预处理
            cv.cvtColor(matSrc, matDst, cv.COLOR_RGBA2RGB);
            
            // B. 遮罩逻辑 (ROI) - Python复刻
            // 创建全黑 mask
            matMask.setTo([0, 0, 0, 0]);
            // 挖白框: x=180, y=150, w=245, h=240 (Python坐标)
            let rect = new cv.Rect(180, 150, 245, 240);
            cv.rectangle(matMask, rect, [255, 255, 255, 255], -1);
            
            // matRoi 存放遮罩后的图
            matRoi.setTo([0,0,0,0]);
            cv.bitwise_and(matDst, matDst, matRoi, matMask);

            // C. 颜色识别
            cv.GaussianBlur(matRoi, matBlur, new cv.Size(9, 9), 2, 2);
            cv.cvtColor(matBlur, matHsv, cv.COLOR_RGB2HSV);
            
            // 利用 matMask 复用内存做颜色掩码
            let tempMask = new cv.Mat(); 
            
            let color = "--";
            let colorHex = "#ccc";
            
            // 查蓝
            cv.inRange(matHsv, matLowB, matHighB, tempMask);
            let contours = new cv.MatVector(); 
            let hier = new cv.Mat();
            cv.findContours(tempMask, contours, hier, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
            
            let bFound = false;
            for(let i=0; i<contours.size(); ++i) {
                if(cv.contourArea(contours.get(i)) > 1800) {
                    bFound = true;
                    cv.drawContours(matDst, contours, i, [0, 0, 255, 255], 3); // 画蓝线
                }
            }
            
            if(bFound) {
                color = "蓝色"; colorHex = "#165DFF";
            } else {
                // 查红
                let mask1 = new cv.Mat(); let mask2 = new cv.Mat();
                cv.inRange(matHsv, matLowR1, matHighR1, mask1);
                cv.inRange(matHsv, matLowR2, matHighR2, mask2);
                cv.bitwise_or(mask1, mask2, tempMask);
                mask1.delete(); mask2.delete();
                
                contours.delete(); contours = new cv.MatVector();
                cv.findContours(tempMask, contours, hier, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
                for(let i=0; i<contours.size(); ++i) {
                    if(cv.contourArea(contours.get(i)) > 1800) {
                        color = "红色"; colorHex = "#F53F3F";
                        cv.drawContours(matDst, contours, i, [255, 0, 0, 255], 3); // 画红线
                    }
                }
            }
            tempMask.delete(); contours.delete(); hier.delete();

            // D. 角度计算 (修复 Missing field 问题)
            let angle = "--°";
            
            if(refImgReady) {
                cv.cvtColor(matRoi, matGray, cv.COLOR_RGB2GRAY);
                orb.detectAndCompute(matGray, new cv.Mat(), webKp, webDesc);
                
                if(!webDesc.empty() && !refDesc.empty()) {
                    try {
                        matcher.knnMatch(refDesc, webDesc, matches, 2);
                        
                        goodMatches = [];
                        for (let i = 0; i < matches.size(); ++i) {
                            let m = matches.get(i).get(0);
                            let n = matches.get(i).get(1);
                            if (m.distance < 0.75 * n.distance) {
                                goodMatches.push(m);
                            }
                        }
                        
                        // 绘制匹配数量
                        cv.putText(matDst, "Matches: " + goodMatches.length, {x:10, y:30}, cv.FONT_HERSHEY_SIMPLEX, 1, [0,255,0,255], 2);

                        if(goodMatches.length > 30) {
                            // === 核心修正：手动构建 Float32 矩阵 ===
                            // 之前 matFromName 容易出错，我们手动申请内存
                            let srcPoints = new cv.Mat(goodMatches.length, 1, cv.CV_32FC2);
                            let dstPoints = new cv.Mat(goodMatches.length, 1, cv.CV_32FC2);
                            
                            for (let i = 0; i < goodMatches.length; i++) {
                                let m = goodMatches[i];
                                let sp = refKp.get(m.queryIdx).pt; // 模板点
                                let dp = webKp.get(m.trainIdx).pt; // 屏幕点
                                
                                // 直接写入数据区，避免类型转换错误
                                srcPoints.data32F[i*2] = sp.x;
                                srcPoints.data32F[i*2+1] = sp.y;
                                dstPoints.data32F[i*2] = dp.x;
                                dstPoints.data32F[i*2+1] = dp.y;
                            }
                            
                            // 计算单应性
                            let H = cv.findHomography(srcPoints, dstPoints, cv.RANSAC, 5.0, matHomMask);
                            
                            if(!H.empty()) {
                                // 取出矩阵元素
                                let m00 = H.data64F[0];
                                let m01 = H.data64F[1];
                                // 计算角度
                                let theta = -Math.atan2(m01, m00) * 180 / Math.PI;
                                angle = Math.round(theta) + "°";
                                
                                // 可视化中心点
                                cv.circle(matDst, {x:320, y:240}, 5, [0,255,255,255], -1);
                                
                                H.delete();
                            }
                            srcPoints.delete(); dstPoints.delete();
                        }
                    } catch(e) {
                        console.log("Homography error: ", e);
                    }
                }
            }

            // 画出 ROI 框
            cv.rectangle(matDst, {x:180, y:150}, {x:425, y:390}, [255, 255, 0, 255], 2);

            // 显示
            cv.imshow('canvas', matDst);
            
            // 更新 UI
            document.getElementById('out-color').innerText = color;
            document.getElementById('out-color').style.color = colorHex;
            document.getElementById('out-angle').innerText = angle;
        }
    </script>
</body>
</html>
